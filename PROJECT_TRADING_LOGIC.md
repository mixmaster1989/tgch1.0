### MEXCAITRADE — Полная логика покупок, продаж и балансировки

Документ описывает, как проект торгует (покупает/продает), как балансирует портфель и какие механизмы безопасности применяет. Основано на исходниках: `main.py`, `market_scanner.py`, `balance_monitor.py`, `pnl_monitor.py`, `active_50_50_balancer.py`, `mex_api.py`, `mexc_advanced_api.py`, `market_analyzer.py`, `native_trader_bot.py`, `config.py`.

---

## Архитектура и поток запуска

- **Точка входа**: `main.py`
  - Запускает параллельно (в отдельных потоках):
    - `MarketScanner` — фоновый сканер рынка с автопокупками в USDT рынках
    - `BalanceMonitor` — автопокупки BTC/ETH за USDC с защитами
    - `PnLMonitor` — автопродажа BTC/ETH при достижении порога прибыли, плюс (плановая) балансировка портфеля
    - `AltsMonitor` — монитор альтов (порог $0.15) — не рассматривается подробно здесь
    - `OrdersReporter` — периодические отчеты по ордерам
    - `Active5050Balancer` — активная балансировка 50/50 (Альты vs BTC/ETH) за USDC
  - После старта — запускает `NativeTraderBot` (Telegram-поведение, отчеты, статусы)

- **Интеграция с биржей**: through `MexAPI` и `MexAdvancedAPI`.
  - `MexAPI` — базовые REST вызовы, с ретраями, fallback’ами (v2) для цен/свечей
  - `MexAdvancedAPI` — правила лотов/точности, комиссии, история сделок (для расчета средней цены)

- **Конфигурация**: `config.py`
  - API ключи, Telegram, OpenRouter
  - Глобальные настройки торговли (дефолтные лимиты), PnL-монитора и исключения символов

---

## Покупки: два независимых контура

### 1) Автопокупки альтов в USDT рынках — `MarketScanner`

- Файл: `market_scanner.py`
- Цикл: каждые `scan_interval=600` сек (10 мин)
- Шаги:
  1. Получает топ USDT-пар по `get_24hr_ticker()` → фильтрует по объему > $10k, исключает пары из `EXCLUDED_SYMBOLS` (`config.EXCLUDED_SYMBOLS`).
  2. Для каждой пары тянет свечи `get_klines(symbol, '15m', 24)` с локальными ретраями.
  3. Считает технические индикаторы через `TechnicalIndicators` (RSI, MACD-сигнал, позиция относительно Bollinger, соотношение объемов) и присваивает скор + причины.
  4. Прогоняет анти‑хайп фильтр `AntiHypeFilter.check_buy_permission(symbol)`; если блок, скор = -10.
  5. Формирует списки: `buy_opportunities` (score>2), neutral, blocked.
  6. Отправляет отчёт в Telegram (редуцированная частота, чтобы не спамить).
  7. Автопокупка: если есть возможности и баланс USDT ≥ $6 — берёт лучшую возможность и считает сумму покупки:
     - если USDT < $20 → тратит 60% баланса; иначе 30% баланса, но не более $50; минимум $6.
  8. Покупка выполняется в `execute_purchase(symbol, usdt_amount, opportunity)`:
     - Получает текущую цену, рассчитывает «сырое» количество.
     - Делает до 6 попыток с разными способами округления количества: по биржевым правилам (через `MexAdvancedAPI.get_symbol_rules`, `stepSize`, `quantityPrecision`, `minQty`) и фиксированные точности 3–6/2 знаков.
     - Размещает рыночный ордер: `mex_api.place_order(symbol, 'BUY', quantity, price=None)`.
     - При успехе — шлёт подробный отчет в Telegram с расшифровкой причин (RSI/объем/MACD, прогноз).

- Безопасности и ограничения:
  - Минимальная сумма — $6.
  - Исключения символов на уровне конфигурации.
  - Ограничение параллельности анализа (до 10 потоков).
  - Снижение частоты Telegram-отчётов.

### 2) Автопокупки BTC/ETH за USDC — `BalanceMonitor`

- Файл: `balance_monitor.py`
- Цель: расходовать только реальные USDC, поддерживая защитный остаток и приоритетно выставляя лимитные ордера близко к рынку (часто — как мейкер).
- Основные настройки:
  - `min_balance_threshold = $10` — минимум USDC, чтобы начать покупку
  - `max_purchase_amount = $100` — максимум за одну покупку
  - `min_usdc_balance_after_purchase = $2` — защита остатка USDC после покупки (всегда оставить минимум)
  - Аллокация: `btc_allocation=60%`, `eth_allocation=40%`
  - Кулдаун между покупками: `min_purchase_interval = 300` сек

- Поток:
  1. Читает балансы USDC/USDT. Тратить можно только USDC для `BTCUSDC`/`ETHUSDC` пар.
  2. Считает безопасную сумму `calculate_safe_purchase_amount(available_usdc)` с учётом остатка и лимитов.
  3. Определяет текущее распределение портфеля в $ (через цены `BTCUSDC`/`ETHUSDC`). Если отклонение от цели (60/40) > 10 п.п., включает режим ребалансировки: покупает только недостающий актив.
  4. Считает минимальные требуемые суммы к покупке: BTC ≥ 0.0001 BTC, ETH ≥ 0.001 ETH; при нехватке — стратегически берёт только один актив.
  5. Прогоняет фильтры:
     - Обычный `AntiHypeFilter` или ребалансировочный `RebalancerAntiHypeFilter`.
     - Применяет множитель: DCA-усиление (×2) при «просадках», либо подавление покупки (<1.0) при хайпе.
  6. Генерирует план `purchase_plan`: символ → {amount, quantity, price, currency, filter_reason, filter_multiplier}.
  7. Выставляет лимитные ордера через `place_limit_order(symbol, quantity)`:
     - Анализ стакана `get_orderbook_data(symbol)` (лучшая покупка/продажа, спред, объемы), выбор цены:
       - покупка: либо по лучшей `ask` (мейкер), либо чуть ниже `ask` (при широком спреде — 0.05%).
     - Проверяет минимумы лота, баланс, при необходимости корректирует количество.
     - Делает до 3 ретраев.
  8. Формирует отчёт и периодически отправляет в Telegram (с анти‑спам контролем), включая:
     - статус мейкер/тейкер, лимит/рынок, ордербук, причины и множители фильтров, статистику.

- Дополнительно:
  - `ensure_usdc_for_trade(required_usdc)` при нехватке может купить USDC за USDT (`USDCUSDT` BUY маркетом) небольшими квантами.

---

## Продажи: PnL‑триггер и пост‑балансировка

### Автопродажа BTC/ETH при прибыли — `PnLMonitor`

- Файл: `pnl_monitor.py`
- Задача: периодически проверять PnL и продавать актив, если прибыль больше `profit_threshold`.
- Настройки из `config.PNL_MONITOR_CONFIG`:
  - `profit_threshold = 0.07` (7 центов) — низкий порог для «подвижного» аккаунта
  - `check_interval = 60` сек, `notification_interval = 600` сек
  - `trading_pairs = ["BTCUSDC", "ETHUSDC"]`
  - Включены `auto_sell_enabled`, `telegram_notifications`, файловое логирование (`pnl_monitor.log` ротация)

- Расчёт прибыли:
  1. Получает балансы активов (`get_balances`).
  2. По каждому активу (BTC/ETH): тянет цену, строит «среднюю цену закупа» через историю сделок:
     - Использует `MexAdvancedAPI.get_my_trades(symbol, limit=500)`.
     - Пересчитывает скользящую среднюю стоимость позиции с учетом комиссий в котируемой валюте (`_calculate_avg_cost_pnl`), аккумулируя реализованный и нереализованный PnL.
  3. Если нереализованный PnL > `profit_threshold`, инициирует продажу.

- Исполнение продажи:
  - `market_sell(symbol, quantity)` — фактически лимитная продажа немного ниже рынка: `limit_price = current_price * 0.999` (−0.1%), чтобы быстро исполнилось.
  - Отправляет детальный Telegram‑алерт с причинами и параметрами ордера.
  - После успешной продажи вызывает `PostSaleBalancer.rebalance_on_freed_funds()` (если доступен), чтобы перераспределить освободившиеся средства.

- Периодические сводки:
  - Каждые ~5 минут шлёт репорт: стоимость BTC/ETH портфеля, общий портфель с учетом стейблов, PnL по активам.

---

## Балансировка портфеля: две линии

### 1) Активная 50/50 (Альты vs BTC/ETH) — `Active5050Balancer`

- Файл: `active_50_50_balancer.py`
- Цикл: каждые `scan_interval=60` сек
- Цель: поддерживать ~50/50 распределение стоимости между «альты» и «BTC/ETH», оперируя только USDC.
- Настройки и защиты:
  - `min_balance_threshold = $10` — минимум USDC для операции
  - `max_balance_threshold = $100` — максимум USDC за одну операцию
  - `min_usdc_balance_after_operation = $20` — защищённый остаток USDC (резерв под скальперов)
  - Минимальное отклонение для балансировки: `min_deviation_threshold = 10%`
  - Кулдаун между операциями: `min_balance_cooldown = 60` сек

- Механика:
  1. Оценивает стоимость портфеля:
     - BTC/ETH оценивает по `BTCUSDC`/`ETHUSDC` и конвертирует в USDT через курс `USDCUSDT`.
     - Альты — все активы, кроме `USDT`/`USDC`/`BTC`/`ETH`, по их `ASSETUSDT`.
  2. Считает текущие доли, сравнивает с целями (50/50), проверяет отклонение > 10%.
  3. Формирует план:
     - если альтов больше нормы и BTC/ETH меньше → `BUY_BTCETH_USDC` на сумму `min(safe_amount, |отклонение|*0.5)`;
     - если наоборот → `BUY_ALTS_USDC` аналогично.
  4. Проверяет `can_make_operation(amount)`: остаток USDC после операции не должен быть < `min_usdc_balance_after_operation` + кулдаун.
  5. Исполняет:
     - `BUY_BTCETH_USDC`: покупать `BTCUSDC` и `ETHUSDC` в пропорции 60/40 рыночными ордерами.
     - `BUY_ALTS_USDC`: покупка набора ликвидных альтов `ADAUSDC`, `DOTUSDC`, `LINKUSDC`, `MATICUSDC`, `AVAXUSDC` равными долями (если сумма мала — берёт один символ).
  6. Отправляет отчет в Telegram (анти‑спам контролируется счётчиком).

### 2) Периодическая балансировка в PnL‑мониторе — `PortfolioBalancer`

- В `pnl_monitor.py` вызывается `portfolio_balancer.execute_portfolio_rebalance()` по интервалу (дефолт ~час).
- Включена защита: при отрицательном общем PnL балансировка может быть заблокирована (`allow_negative_pnl_rebalance == False`). При блоке отправляется уведомление.

---

## Слой API и исполнение ордеров

### `mex_api.py`
- Базовые методы: `get_account_info`, `get_ticker_price`, `get_klines`, `get_24hr_ticker`, `get_depth`, `get_exchange_info`, `place_order` (market/limit по переданному `price`), `get_open_orders`, `get_order_history`, `cancel_order`.
- Особенности:
  - Ретраи с экспоненциальной задержкой.
  - Fallback для цен и свечей на открытый v2 API, конвертация символов (`_to_v2_symbol`).
  - Округление количества `_round_quantity` по `LOT_SIZE` если доступно, иначе до 6 знаков.

### `mexc_advanced_api.py`
- `get_symbol_rules(symbol)` — достаёт фильтры `LOT_SIZE`, `PRICE_FILTER`, `MIN_NOTIONAL`, точности цен/количества.
- `get_my_trades(symbol)` — история сделок (обработанная), используется для средней цены.
- `get_trade_fee`/`get_symbol_fee` — комиссии мейкер/тейкер (дефолт 0.1% если нет данных).
- `calculate_min_order_size` — минимальный ордер в USDT по правилам.

---

## Telegram‑интеграция и отчёты

- Все основные компоненты шлют статусы/отчёты в Telegram: старты, успехи, ошибки, периодические сводки.
- `NativeTraderBot` (`native_trader_bot.py`) обрабатывает сообщения, даёт статусы по командам: портфель, автопокупки, PnL‑монитор, история ордеров. Также отправляет периодическую активность.

---

## Конфигурация и параметры

- `config.py`:
  - `MEX_API_KEY`, `MEX_SECRET_KEY`, `MEX_SPOT_URL`, `MEX_WEBSOCKET_URL`
  - Telegram: `TELEGRAM_BOT_TOKEN`, `TELEGRAM_CHAT_ID`
  - Торговые дефолты: `DEFAULT_TRADE_AMOUNT`, `MAX_POSITIONS`, `STOP_LOSS_PERCENT`, `TAKE_PROFIT_PERCENT` (используются частично)
  - Исключенные символы для сканера: `EXCLUDED_SYMBOLS`
  - `PNL_MONITOR_CONFIG`: пороги и интервалы PnL‑монитора, лог‑файл

---

## Правила управления рисками и защиты

- **Минимумы по суммам**:
  - Сканер рынка: минимум $6 на покупку в USDT рынках.
  - Балансировщик 50/50: минимум $5 на операцию/на один актив, минимум $10 USDC для запуска операции.
  - Монитор баланса: минимум $10 USDC для старта покупки, максимум $100 за одну покупку.
- **Остатки USDC**:
  - Монитор баланса: после покупки должно остаться ≥ $2 USDC.
  - Активная балансировка: после операции должно оставаться ≥ $20 USDC (резерв под скальперов).
- **Кулдауны**:
  - Монитор баланса: ≥ 300 сек между покупками.
  - Активная балансировка: ≥ 60 сек между операциями.
- **Биржевые ограничения** (шаг/минимум лота) соблюдаются через `MexAdvancedAPI` или корректировки количества и ретраи.
- **Анти‑хайп и ребаланс‑фильтры** подавляют/усиливают покупки (множитель ×2 для DCA, <1 для хайпа).
- **Анти‑спам в Telegram**: отчёты отправляются с пониженной частотой через счётчики.

---

## Как это работает вместе (сценарии)

- Свободные USDC ≥ $10 → `BalanceMonitor` планирует и исполняет лимитные покупки BTC/ETH, стремясь к 60/40, с учётом фильтров и мейкерной логики по стакану.
- На рынке появляется «вкусная» альта с хорошим скором → `MarketScanner` покупает рыночным ордером на рассчитанную долю USDT‑баланса.
- Позиции BTC/ETH в плюсе > $0.07 (нереализованный) → `PnLMonitor` продаёт лимитом близко к рынку, затем (опционально) триггерит пост‑балансировку.
- Доля альтов уехала от 50/50 > 10% → `Active5050Balancer` делает USDC‑операцию (покупка альтов или BTC/ETH), соблюдая защитный остаток USDC.

---

## Расширение и замечания по реализации

- Для стабильности исполнения лимитных стратегий (мейкер) целесообразно:
  - добавить авто‑перевыставление при неисполнении/слишком узком спреде;
  - учитывать динамику стакана (подтягивание цены) с таймаутом.
- В `MarketScanner` округление количества уже ретраится по множеству стратегий; при частых отказах сто́ит логировать ответы API глубже.
- В `PnLMonitor` расчет средней цены реализован через историю сделок и комиссии; при нестандартных комиссиях (в иных активах) учтён конверт в котируемую валюту.
- Для унификации метрик и отчётов о портфеле есть интеграция через `PortfolioAnalyzer` (вызывается ботом для отчётов).

---

## Краткая шпаргалка по важным функциям

- Покупка альтов (USDT): `MarketScanner.execute_purchase`
- Покупка BTC/ETH (USDC, лимит): `BalanceMonitor.place_limit_order`
- План покупок и фильтры (BTC/ETH): `BalanceMonitor.calculate_purchase_amounts`
- Продажа по прибыли: `PnLMonitor.market_sell` + `_calculate_avg_cost_pnl`
- Активная балансировка 50/50: `Active5050Balancer.calculate_balance_needed` → `execute_balance_operation`
- API: `MexAPI.place_order` (market/limit), `MexAdvancedAPI.get_symbol_rules`, `get_my_trades`

---

## Приложение: основные параметры по умолчанию

- MarketScanner:
  - `scan_interval=600s`, max 200 пар, min buy $6, отчёты раз в 2 цикла
- BalanceMonitor (USDC → BTC/ETH):
  - `min_balance_threshold=$10`, `max_purchase_amount=$100`, остаток ≥ $2, кулдаун 300s, цели 60/40, ребаланс >10 п.п., лимитные ордера по стакану
- PnLMonitor:
  - `profit_threshold=$0.07`, `check_interval=60s`, отчёты раз в 2 интервала, лимитная продажа −0.1% от рынка
- Active5050Balancer:
  - `scan_interval=60s`, `min_balance_threshold=$10`, `max_balance_threshold=$100`, остаток ≥ $20, отклонение >10%, кулдаун 60s

---

Если потребуется, можем расширить документ разделами с примерами телеграм‑отчетов, типовыми логами (`pnl_monitor.log`) и схемами последовательностей для каждой ветки исполнения. 